import { createOctokitClient } from "../appAuth.js";



export const commentOnIssue = async (req, res) => {
  // console.log("Req recieved");
  console.log(req.body);
  const event = req.headers["x-github-event"];
  const action = req.body.action;
  if (event === "issues" && action === "opened") {
    const issue = req.body.issue;
    const repo = req.body.repository;
    const installationId = req.body.installation.id;
    const owner = repo.owner.login;
    const repoName = repo.name;
    const issueNumber = issue.number;
    const octokitClient = createOctokitClient(installationId);
    try {
      const res = await octokitClient.request("POST /repos/{owner}/{repo}/issues/{issue_number}/comments", {
        owner,
        repo: repoName,
        issue_number: issueNumber,
        body: "Thanks for opening this issue! The bot is active(Commiting Now!).",
      });
      console.log(res);
    } catch (error) {
      console.log(error);
      res.status(401).json({ message: "An Error Occured" });
    }
  } else {
    res.status(400).json({ message: "Invalid dude" });
  }
};

export const createCommit = async (req, res) => {
  console.log("Req recieved");

  // commentOnIssue(req, res);
  const event = req.headers["x-github-event"];
  const action = req.body.action;

  if (event === "issues" && action === "opened") {
    const issue = req.body.issue;
    const repo = req.body.repository;
    const installationId = req.body.installation.id;
    const owner = repo.owner.login;
    const repoName = repo.name;
    const issueNumber = issue.number;
    const octokitClient = createOctokitClient(installationId);

    // gets the base branch (main/ master)

    console.log("Getting the base branch: ");
    const { data: repoData } = await octokitClient.repos.get({
      owner,
      repo: repoName,
    });
    const baseBranch = repoData.default_branch;

    try {
      // Getting the SHA of the last commit after which we want to commit
      console.log("Getting the last head of main branch: ");
      const { data: refData } = await octokitClient.rest.git.getRef({
        owner: owner,
        repo: repoName,
        ref: `heads/${baseBranch}`, // e.g., 'heads/main' or 'heads/master'
      });
      const commitSha = refData.object.sha;
      console.log("Commit SHA: ", commitSha);
    } catch {
      console.log("No Commit found!");
      return res.status(404).json({ msg: "Empty Repository, no commit found!" });
    }

    // Creating a new branch off the current commit SHA
    console.log("Creating a new Branch: ");
    const newBranchName = `docbot/docs-${Date.now()}`;
    const { data: newRef } = await octokitClient.git.createRef({
      owner,
      repo: repoName,
      ref: `refs/heads/${newBranchName}`,
      sha: commitSha,
    });
    const newTreeSha = newRef.object.sha;

    // Create Document to be committed
    // TODO: create a separate function for this where there is an AI call
    console.log("Creating Document ");
    const docContent = `# Auto-Generated Documentation\n\nGenerated by @docbot on ${new Date().toISOString()}`;
    const { data: blobData } = await octokitClient.git.createBlob({
      owner,
      repo: repoName,
      content: docContent,
      encoding: "utf-8",
    });

    // Create new tree(branch)
    console.log("Creating new Tree ");
    const { data: newTree } = await octokitClient.git.createTree({
      owner: owner,
      repo: repoName,
      base_tree: newTreeSha, // base is the latest commit's tree
      tree: [
        {
          path: "docs/generated-README.md",
          mode: "100644",
          type: "blob",
          sha: blobData.sha,
        },
      ],
    });

    // Create a commit
    console.log("Commiting on that Tree");
    const { data: newCommit } = await octokitClient.git.createCommit({
      owner,
      repo: repoName,
      message: "Im commiting!",
      tree: newTree.sha,
      parents: [commitSha],
    });

    // Update the head of the new branch to the katest commit
    console.log("Updating the head of that branch to the new commit SHA ");
    await octokitClient.git.updateRef({
      owner,
      repo: repoName,
      ref: `heads/${newBranchName}`,
      sha: newCommit.sha,
    });

    // Create a pull Request
    console.log("Creating Pull Request");
    try {
      const res = await octokitClient.request("POST /repos/{owner}/{repo}/pulls", {
        owner,
        repo: repoName,
        issue_number: issueNumber,
        head: newBranchName,
        base: baseBranch,
        title: "Dummy Title",
      });
      console.log("PR Created!");
    } catch (error) {
      console.log(error);
      res.status(401).json({ message: "An Error Occured" });
    }
  } else {
    res.status(400).json({ message: "Invalid dude" });
  }
};

export const detectMergePR = async (req, res) => {
  // console.log("Headers:", req.headers);
  // console.log("Body:", req.body);

  const event = req.headers["x-github-event"];
  const action = req.body.action;

  // Handle pull request events (closed/merged)
  if (event === "pull_request" && action === "closed") {
    console.log("Pull Request Closed Detected!");
    // console.log("Headers:", req.head);
    // console.log("Body:", req.body);

    const pr = req.body.pull_request;
    const mergedStatus = pr.merged;
    const branchRef = pr.head.ref;

    if (branchRef.startsWith("docbot/docs-")) {
      const repo = req.body.repository;
      const installationId = req.body.installation.id;
      const owner = repo.owner.login;
      const repoName = repo.name;
      const octokitClient = createOctokitClient(installationId);

      console.log(`PR was ${mergedStatus ? "merged" : "closed without merging"}`);
      console.log(`Branch to delete: ${branchRef}`);

      octokitClient.rest.git.deleteRef({
        owner: owner,
        repo: repoName,
        ref: `heads/${branchRef}`,
      });

      console.log("Branch Deleted Successfully");
    } else {
      console.log("Branch was not Generated by docbot, skipping...");
    }
  }

  res.status(200).json({ message: "Webhook processed successfully" });
};
